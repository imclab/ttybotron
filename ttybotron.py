"""
TTYBOTRON
=========
A TTY Tubotron.

.. todo::
 * Command line args for:
   * Port to listen on
   * Filtering by IP, chip, core, etc.
"""

import socket, struct, sys, threading, time

def make_socket( port ):
    """Make an appropriate socket for receiving SDP packets.

    :param port: Port to listen on.
    :returns: An open socket.
    """
    # Instantiate the socket, set non-blocking
    _socket = socket.socket( socket.AF_INET, socket.SOCK_DGRAM )
    _socket.setblocking( 0 )
    _socket.bind( ( "", port ) )
    return _socket

class SDPPrintPacket( object ):
    """An SDP Packet as generated by the spin1_printf or similar function.

    :param data: An array of bytes as received from a socket.
    :type data: array
    """
    def __init__( self, data ):
        # Process the data and save
        header = data[2:2+8]
        data = data[2+8+4:]

        # Unpack the header
        (flags, iptag, dest_port, srce_port, dest_addr, srce_addr) = (
            struct.unpack( "!4B 2H", header ) )
   
        (chip_x, chip_y) = (
            struct.unpack( "2B", struct.pack( "H", srce_addr ) ) )
  
        core = srce_port & 0x1f

        # Save all this data
        self.flags = flags
        self.iptag = iptag
        self.dest_port = dest_port
        self.srce_port = srce_port
        self.dest_addr = dest_addr
        self.srce_addr = srce_addr

        self.chip_x = chip_x
        self.chip_y = chip_y
        self.core = core

class SDPPrintReceiver( threading.Thread ):
    """Creates a thread which keeps trying to receive SDP messages.  When a 
    message is received the provided callback is called with the message.

    :param socket: Socket to check.
    :param callback: Function to call when a packet is received.
    """
    def __init__( self, socket, callback ):
        # Call super
        super( SDPPrintReceiver, self ).__init__()

        # Save the socket and callback
        self._socket = socket
        self._callback = callback

        # State
        self.exit = False

    def run( self ):
        # Run as long as we can...
        while not self.exit:
            # Try to receive a packet
            try:
                data = self._socket.recv( 1024 )

                # Call the callback with the packet
                packet = SDPPrintPacket( data )
                self._callback( packet )
            except IOError: # There was nothing to get
                pass
            finally:
                time.sleep( 0.1 )

def ttybotron( port = 17892 ):
    """Continue to poll an incoming socket on the appropriate port and print
    out a formatted string of the machine, chip, core and message."""
    # Set up the socket
    sock = make_socket( port )

    try:
        # Create a call back function
        def printer( packet ):
            """Prints an SDP Packet."""
            sys.stdout.write( "(%s, %2d, %2d, %2d) %s" % (
                                "",
                                packet.chip_x,
                                packet.chip_y,
                                packet.core,
                                packet.data
                            )
            )
            sys.stdout.flush()

        # Make and run the socket receiving thread
        recvr = SDPPrintReceiver( sock, printer )
        recvr.start()

        while True:
            pass
    except KeyboardInterrupt:
        recvr.exit = True
    finally:
        # Wait for the receiver, close the socket
        recvr.join()
        sock.close()

        # Flush outputs
        sys.stdout.flush()
        sys.stderr.write("\n")
        sys.stderr.flush()

if __name__ == "__main__":
    ttybotron( )
